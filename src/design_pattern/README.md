# 4. 디자인 패턴

</br>

# 4.1. 디자인 패턴의 이해

**디자인 패턴이란** 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 수 있는 훌륭한 해결책이라고 이해하면 된다.

**패턴이란**  각기 다른 소프트웨어 모듈이나 기능을 가진 다양한 응용 소프트웨어 시스템들을 개발할 때 서로 간에 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에 존재하는 유사점

</br>

* **디자인 패턴 구조**
  * **콘텍스트(context)** : 패턴이 적용될 수 있는 상황
  * **문제(problem)** : 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들
  * **해결(solution)** : 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계들

</br>

* **패턴 구분**
  * **아키텍처 패턴** : 시스템을 구성하는 컴포넌트의 구성과 컴포넌트 사이의 협조 방법을 패턴화한 것이다.
  * **디자인 패턴** : 아키텍처 패턴에서 컴포넌트의 내부 구조를 대상으로 한 클래스/객체의 구조와 협업 방법을 패턴화한 것이다.
  * **관용구** : 각각의 프로그램 언어 특유의 패턴. 프로그래밍에서 자주 사용하는 기술 방법(코딩 방법)을 패턴화한 것이다.

</br>

# 4.2. GoF 디자인 패턴

**GoF(Gang of Four)** : 소프트웨어 개발 영역에서 디자인 패턴을 구체화하고 체계화한 것

</br>

**GoF 디자인 패턴의 분류**

* **생성 패턴** 
  * 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.
  * ex) 추상 팩토리, 빌더, 팩토리 메서드, 프로토타입, 싱글턴
* **구조 패턴**
  * 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이다.
  * ex) 어댑터, 브리지, 컴퍼지트, 데커레이터, 퍼사드, 플라이웨이트, 프록시
* **행위 패턴**
  * 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴이다.
  * 책임 연쇄, 커맨드, 인터프리터, 이터레이터, 미디에이터, 메멘토, 옵서버, 스테이트, 스트래티지, 템플릿 메서드, 비지터

</br>

**책에서 다루는 10가지 GoF 패턴**

| 패턴 분류 | 패턴 이름                      | 패턴 설명                                                    |
| --------- | ------------------------------ | ------------------------------------------------------------ |
| 생성 패턴 | 추상 팩토리(Abstract Factory)  | 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴 |
|           | 팩토리 메서드(Factory Method)  | 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴 |
|           | 싱글턴(Singleton)              | 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴 |
| 구조 패턴 | 컴퍼지트(Composite)            | 여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴 |
|           | 데커레이터(Decorator)          | 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴 |
| 행위 패턴 | 옵서버(Observer)               | 한 객체의 상태 변화에 따라 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴 |
|           | 스테이트(State)                | 객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴        |
|           | 템플릿 메서드(Template Method) | 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴 |
|           | 커맨드(Command)                | 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴 |

</br>

# 4.3. UML과 디자인 패턴

* **컬레보레이션(collaboration)** : UML 2.0에서 디자인 패턴을 표현하는 도구
* **순차 다이어그램(sequence diagram)** : 행위적인 면을 모델링하는 도구

</br>

## 4.3.1. 컬레보레이션

여기에서 주목할 점은 **객체와 역할 사이의 관계다.** 어떤 일을 수행할 때 객체는 각자 주어진 상황에서 주어진 역할에 따른 책임을 수행한다. 

 디자인 패턴 역시 목적을 달성하기 위한 역할들의 **상호 협동 작업으로** 간주할 수 있다. 그리고 UML에서는 객체들이 특정 상황에서 수행하는 역할의 상호작용을 **컬레보레이션이라는** 요소로 작성한다.

<u>컬레보레이션은 점선으로 된 타원 기호를 사용하며, 타원 내부에 협력을 필요로 하는 역할들과 그들 사이의 연결 관계를 표현한다.</u> 

* **예시) 대출 관계 컬레보레이션**

<img src="../../capture/스크린샷 2019-08-12 오후 10.29.08.png" width=500>

>  컬레보레이션은 역할들의 상호작용을 추상화한 것으로, 특별한 상황에 적용하면 많은 시스템 개발에 재사용할 수 있다.

</br>

**컬레보레이션 어키런스(collaboration occurrence)** : 더 구체적인 상황에서의 컬레보레이션 적용을 표현해준다.

* **예시) 은행에서의 담보 대출 컬레보레이션 어키런스**

<img src="../../capture/스크린샷 2019-08-12 오후 10.45.32.png" width=500>

> 컬레보레이션 어키런스는 컬레보레이션에 참가하는 응용 클래스에 의존하며 의존 관계에 붙은 레이블은 응용 클래스가 컬레보레이션에 수행하는 역할을 나타낸다.

</br>

## 4.3.2. 순차 다이어그램

**순차 다이어그램은** UML 2.0에서 객체들의 상호작용을 나타내는 다이어그램 중 하나다. 순차 다이어그램은 객체들 사이의 메시지 송신과 그들의 순서를 나타낸다.

* **객체의 3가지 표현**

<img src="../../capture/스크린샷 2019-08-12 오후 10.51.38.png" width=500>

* **여러 가지 형태의 메시지 표현**

  <img src="../../capture/스크린샷 2019-08-12 오후 11.05.28.png" width=700>

  * 객체 사이의 메시지는 **화살표로** 표시한다.
    * **비동기 메시지** : 머리 부분이 채워지지 않고 열려 있는 화살표
    * **동기 메시지** : 머리 부분이 채워져 있는 화살표
  * **<<create\>>** : 객체를 생성하는 메시지 표현
  * **<<destroy\>>**  : 객체를 소멸시키는 메시지 표현
  * **메시지 표현** : \[시퀀스 번호]\[가드]: 반환 값 = 메시지 이름(\[인자 리스트])
  * **가드(guard)** : 메시지가 송신되는 데 만족해야 하는 조건
  * **점선 화살표** : 응답 메시지를 표현한다.

</br>

* **프레임을 사용한 순차 다이어그램**

  <img src="https://raw.githubusercontent.com/walbatrossw/java-design-patterns/master/ch04-design-patterns/img/sd-diagram-frame.png">

  * UML 2.0에서는 모든 다이어그램에 다이어그램의 경계, 타입, 이름을 포함한 레이블의 장소를 제공하는 프레임을 제공한다.
  * 순차 다이어그램의 타입에 해당하는 키워드는 `sd`다.
  * 연관 관계의 역할 이름은 연관된 클래스의 객체들이 서로를 참조할 수 있는 속성 이름으로 활용할 수 있다.
  * 순차 다이어그램은 가능한 한 시나리오만 표현해야 한다.

</br>

* **alt 키워드** : 상호작용을 조건에 따라 선택적으로 수행할 수 있게 한다.

  <img src="../../capture/sd-diagram-frame-alt.png">

  > 도서 대여 시나리오에 올바르지 않은 비밀번호를 입력한 경우를 고려해 확장한 순차 다이어그램

</br>

* **loop 키워드** : 반복적인 상호작용을 나타내는 키워드

  <img src="https://raw.githubusercontent.com/walbatrossw/java-design-patterns/master/ch04-design-patterns/img/sd-diagram-frame-alt-roop.png">

  > 올바르지 않은 비밀번호를 입력했을 대 3회까지 비밀번호를 입력하도록 도서 대여 시나리오를 변경한 것.

</br>

## 4.3.3. 순차 다이어그램과 클래스 다이어그램의 관계

**순차 다이어그램** : 객체 사이의 메시지 흐름과 순서를 알려주는 행위 측면에 중점을 두는 모델

**클래스 다이어그램** : 시스템의 구조적인 측면에 중점을 두는 모델